# c＋＋ basic


# 指针和引用

----------------------------------------------------------------
## 1.指针
### 1.1 指针
	①保存地址
	②加*取所指变量
	③运算以相应的类型变量为单位
	结构指针：(*指针).成员 或者  指针—>成员

### 1.2 数组名和指针区别：
数组名本身没有存储空间，不能对数组名进行赋值，数组名就是一个地址；而指针是个变量，本身有自己的存储空间，并且保存指针空间的大小是一样的。例如：

	如，int *p= new int[n]; 
 	例：int a[10]; 
	int *p=a; 
	*a=a[0]=*p; 
	*(a+i) = *(p+i) = a[i]=*p++; 

## 1.3 指针修饰变量
#### 1.3.1 指向常量的指针
是指一个指向常量的指针变量。它不允许改变指针所指的变量，但是可以将这个指针赋予另一个常量。如
	const char * name = “zhang”;//声明指向常量的指针
	name[3]=’a’;//错误，常量不允许修改
	name = “li”;//正确，可以修改指针
	本质：const int *p ;禁止修改*p，禁止通过p去修改它所指向的数据，如下程序

#### 1.3.2 常指针
	定指针，指针指向一个固定的地址，不能指向别处。如
	char * const name = “chang”;//声明为一个名为name的指针变量，该指针是指向字符型数据的常指针，用”chang”的地址来初始化该常指针。
	创建一个常指针就是创建一个不能移动的固定指针，但是它所指的数据可变如下
	name[3]=’a’;//正确
	name = “li”;//错误

#### 1.3.3 指向常量的常指针
是指这个指针本身不能改变，这个指针所指向的常量也不能改变。如
	
	const char * const name=”zhang”;
	name[3]=’a’;//错误
	name=”li”;//错误

### 1.4 函数指针
	函数指针:函数也有地址，函数名表示地址
	类型：去掉函数名，剩下的就是类型
	除有赋值和调用，没有任何运算，不能输出函数指针的值
	像声明函数一样定义函数指针，把函数名改成(*指针)
	例如：basic/func_point.cpp


### 1.5 注意：
	1.5.1 不管什么指针都占4个字节内存空间(32位占4个字节，64位占8个字节)。例，basic/size_point.cpp
	1.5.2 字符指针，当输出字符指针的地址时，输出的是从这个地方一直遇到\0时停止。例，basic/character_point.cpp


## 2.引用
### 2.1
	常量引用：(1)接受常量的初始化
			(2)禁止修改这个引用
	原则：(1)尽量用引用传递参数
		(2)尽量用const限制对引用的修改
	一个变量的类型和地址都是终身不变的

### 2.2 引用和非引用的区别
	引用：直接使用实参
	非引用：会把实参复制一份给形参
	形参：是一个新变量，调用的时候时创建，有实参来初始化


## 3. 使用指针和引用的注意事项
	(1)保证那个变量有”以后”
	(2)从函数返回的那个变量还存在。例如：basic/var_exists_point.cpp
	(3)引用和指针必须初始化

----------------------------------------------------------------

# 类和对象
----------------------------------------------------------------
## 基本介绍
	类的数据成员可是任何数据类型，但不能是自动(auto)、寄存器(register)或外部(extern)；
	不能在类声明中给数据成员赋值，C++规定，只有在类对象定义之后才能给数据成员赋初始值；


## 构造函数和析构函数
在c++中，构造函数完成，为对象分配存储空间和初始化。构造函数是属于某个类的，可以由用户来提供，也可以通过系统自动生成。
析构函数完成，回收存储空间，并做些善后工作。

### 构造函数
#### 特点
		构造函数名字必须与类的名字相同
		构造函数可以由任意类型参数，但不能有返回类型
		定义对象时，编译系统会自动调用构造函数。不能通过对象显示的调用。
		构造函数可以不带任何参数
#### 构造函数调用
		(1)利用构造函数直接创建对象，其一般形式
			类名  对象名(实参表);
		(2)利用构造函数创建对象时，通过指针和new来实现，其一般形式
			类名 * 指针变量名 =  new 类名(实参表)
			例如：
				complex  *  A = new complex(1,2) 
			就创建了对象 （*A）。

		【说明】
		如果没有定义构造函数，则编译系统会自动生成一个默认的构造函数。例如：
		complex：：complex()
		{
		}
		此时，构造函数只能为对象开辟一个存储空间，而不能对其中的数据成员赋初值，这些初始值将是随机数。

#### 构造函数初始化
		（1）初始化列表
		构造函数可以用构造初始化表对数据成员进行初始化。但如果数据成员存放在堆中或者数组中，则应该在构造函数中使用赋值语句，即使构造函数有初始化列表也是如此。例如：
		class x {
				int i;
				char c;
				float f;
				char name[25];

				public:
					x (int I, char C, float F,char N[]) : i(I) , c (C) , f (F)
					{
						strcpy(name,N);
					}
		};
		（2）初值列表
		对于没有定义构造函数的类，其共有数据成员可以用初始值表进行初始化。例如：
		class myclass {
			public:
				char name[10];
				int no;
		};
		int main ()
		{
			myclass a = {“zhang”,25};
		}
#### 构造函数类别
	1.带默认参数构造函数
		class complex {
			private:
				double real;
				double imag;
			public:
				complex(double r = 0.0 , double i = 0.0);  //含有默认参数的构造函数
		};
		complex::complex(double r , doube i)
		{
			real = r ;
			imag = i;
		}

	2.重载构造函数
		class A {
			public:
				A();			//不带参数构造函数
				A(int);		//只带一个整形参数的构造函数
				A(int,char);	//
				A(float,char);
		};

	3.拷贝构造函数
		拷贝构造函数，主要用于依据已存在的对象，建立一个新对象。其主要特点：
		是一种构造函数，其函数名与类名相同，并且函数也没有返回值类型。
		该函数只有一个参数，并且是同类对象的引用。
		每个类都必须有一个拷贝构造函数。可以自定义拷贝构造函数，也可是使用默认的拷贝构造函数。
		class point {
			int x , y;
			public:
				point (int a , int b)
				{
					x = a;
					y = b;
				}
				point (const point &p)
				{
					x = 2 * p.x;
					y = 2 * p.y;
				}
		};
		int main()
		{
			point p1(30,40);
			point p2(p1);		//用代入法调用拷贝构造函数
			point p3 = p1;		//用赋值法调用拷贝构造函数
		}
	例如：basic/construct.cpp
		basic/construct_point.cpp


	4.默认的拷贝构造函数
	如果没有自定义拷贝构造函数，C++会调用默认拷贝构造函数，自动将一个已存在的对象复制给新对象。但若类中有指针类型时，必须自定义拷贝构造函数进行处理。
	自定义拷贝构造函数后，就没有默认的拷贝构造函数了。







# 派生类和继承
----------------------------------------------------------------




# 多态性
----------------------------------------------------------------




